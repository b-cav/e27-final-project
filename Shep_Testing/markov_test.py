# -*- coding: utf-8 -*-
"""ENGS_27_Final_Project_Starter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wdsH-r2cJ4sVQpKAKyZUe1iuSOgJ6KHc

# ENGS 27 Final Project Starter Code
[Enter Names of Group Members Here]

Please copy this code to work on your own version!

The following code interfaces with the noisy channel, hosted on a Dartmouth website.
"""

import subprocess
import pandas as pd
def noisy_channel(bits: str) -> str:
    """
    Calls curl to POST the given bits to the test.py endpoint
    and returns the stdout response as a string.
    """
    # Build the curl command and arguments:
    cmd = [
        "curl",
        "-X", "POST",
        "-d", f"bits={bits}",
        "https://engs27.host.dartmouth.edu/cgi-bin/noisychannel.py"
    ]

    # Run the command, capture stdout/stderr
    result = subprocess.run(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,       # return strings instead of bytes
        check=False      # weâ€™ll inspect returncode manually
    )

    if result.returncode != 0:
        # curl failed. You can raise, log, or return stderr.
        raise RuntimeError(f"curl failed (code {result.returncode}):\n{result.stderr}")

    return result.stdout.split("<body>")[1].split("</body>")[0]

"""#Example Usage"""
def markov_test(filename="markov_results.csv", trials=250):
    """
    Sends test patterns through the noisy channel and writes results to CSV.
    """
    patterns = ["0", "1", "00", "11", "10", "01"]

    with open(filename, "w") as f:
        f.write("pattern,sent,received\n")
        for pattern in patterns:
            for _ in range(trials):
                received = noisy_channel(pattern)
                # Store the full pattern, and only the *last bit* as sent/received
                f.write(f"{pattern},{pattern[-1]},{received[-1]}\n")

import pandas as pd

def bit_flip_stats(df: pd.DataFrame, return_dict: bool = False):
    """
    Computes conditional bit flip probabilities from dataframe.
    Normalizes columns to strings so filtering works even if CSV was read as integers.

    Columns expected:
      - pattern: '0','1','00','11','10','01' (as strings; if read as ints, '00'/'01' become '0'/'1')
      - sent: last bit sent ('0' or '1')
      - received: last bit received ('0' or '1')

    If you already loaded with integers and lost leading zeros, re-read with:
      df = pd.read_csv("markov_results.csv", dtype={'pattern': str, 'sent': str, 'received': str})
    """
    df = df.copy()

    # Normalize to strings and strip whitespace
    for c in ['pattern', 'sent', 'received']:
        df[c] = df[c].astype(str).str.strip()

    # Flip indicator (last bit flipped or not)
    df['flip'] = (df['sent'] != df['received']).astype(int)

    def mean_flip(mask):
        subset = df.loc[mask]
        if subset.empty:
            return None
        return float(subset['flip'].mean())

    results = {}

    # Single-bit: no preceding
    for bit in ['0', '1']:
        results[f'flip|no_preceding,{bit}'] = mean_flip(df['pattern'] == bit)

    # Two-bit: preceding same/different (Markov behavior on the second bit)
    for bit in ['0', '1']:
        same_pattern = bit * 2              # '00' for 0, '11' for 1
        diff_pattern = ('1' if bit == '0' else '0') + bit  # '10' for 0, '01' for 1
        results[f'flip|preceding_same,{bit}'] = mean_flip(df['pattern'] == same_pattern)
        results[f'flip|preceding_diff,{bit}'] = mean_flip(df['pattern'] == diff_pattern)

    # Pretty print
    def fmt(v):
        return f"{v:.3f}" if v is not None else "N/A (no data)"

    for bit in ['0', '1']:
        print(f"P(flip | no preceding, {bit}) = {fmt(results[f'flip|no_preceding,{bit}'])}")
    for bit in ['0', '1']:
        print(f"P(flip | preceding same, {bit}) = {fmt(results[f'flip|preceding_same,{bit}'])}")
        print(f"P(flip | preceding different, {bit}) = {fmt(results[f'flip|preceding_diff,{bit}'])}")

    if return_dict:
        return results
# Example usage:
# 1. Run markov test once to generate results
#markov_test("markov_results.csv", trials=100)

# 2. Load results and compute probabilities
df = pd.read_csv("markov_results.csv", dtype={'pattern': str, 'sent': str, 'received': str})
bit_flip_stats(df)