# -*- coding: utf-8 -*-
"""ENGS_27_Final_Project_Starter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wdsH-r2cJ4sVQpKAKyZUe1iuSOgJ6KHc

# ENGS 27 Final Project Starter Code
[Enter Names of Group Members Here]

Please copy this code to work on your own version!

The following code interfaces with the noisy channel, hosted on a Dartmouth website.
"""

import subprocess
import numpy as np
import pandas as pd
import datetime as datetime
def noisy_channel(bits: str) -> str:
    """
    Calls curl to POST the given bits to the test.py endpoint
    and returns the stdout response as a string.
    """
    # Build the curl command and arguments:
    cmd = [
        "curl",
        "-X", "POST",
        "-d", f"bits={bits}",
        "https://engs27.host.dartmouth.edu/cgi-bin/noisychannel.py"
    ]

    # Run the command, capture stdout/stderr
    result = subprocess.run(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,       # return strings instead of bytes
        check=False      # weâ€™ll inspect returncode manually
    )

    if result.returncode != 0:
        # curl failed. You can raise, log, or return stderr.
        raise RuntimeError(f"curl failed (code {result.returncode}):\n{result.stderr}")

    return result.stdout.split("<body>")[1].split("</body>")[0]

"""#Example Usage"""

# print(noisy_channel("000101010101010101010100010101010101010101010101010101010101010101010"))
# print(noisy_channel("00000000"))


def stats(message, num_runs):
    distance = [hamming_distance(message, noisy_channel(message)) for _ in range(num_runs)]
    return np.mean(distance), np.std(distance)
        
        
# Return hamming distance between two strings (number of bit flips)
def hamming_distance(message1, message2):
    count = sum(1 for char1, char2 in zip(message1, message2) if char1 != char2)
    return count


# def error_test():
#     results = []
#     for length in range(1, 9):
#         for bit in ['0', '1']:
#             message = bit * length
#             mean, std = stats(message, 50)
#             results.append({
#                 'Bit': bit,
#                 'Length': length,
#                 'Mean Errors': mean,
#                 'Std Dev': std
#             })
#     df = pd.DataFrame(results)
#     print(df)
#     # Simple visualization
#     import matplotlib.pyplot as plt
#     plt.figure(figsize=(8,5))
#     for bit in ['0', '1']:
#         subset = df[df['Bit'] == bit]
#         plt.errorbar(subset['Length'], subset['Mean Errors'], yerr=subset['Std Dev'], label=f'All {bit}s', capsize=4, marker='o')
#     plt.xlabel('Bit Length')
#     plt.ylabel('Mean Hamming Distance (Errors)')
#     plt.title('Noisy Channel Error Statistics')
#     plt.show()
# error_test()

import subprocess
import numpy as np
import pandas as pd
from datetime import datetime

def noisy_channel(bits: str) -> str:
    """
    Calls curl to POST the given bits to the test.py endpoint
    and returns the stdout response as a string.
    """
    cmd = [
        "curl",
        "-X", "POST",
        "-d", f"bits={bits}",
        "https://engs27.host.dartmouth.edu/cgi-bin/noisychannel.py"
    ]
    result = subprocess.run(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=False
    )
    if result.returncode != 0:
        raise RuntimeError(f"curl failed (code {result.returncode}):\n{result.stderr}")
    return result.stdout.split("<body>")[1].split("</body>")[0].strip()

# Hamming distance between two bit strings
def hamming_distance(message1: str, message2: str) -> int:
    return sum(1 for a, b in zip(message1, message2) if a != b)

def gen_pattern(pattern_type: str, n: int) -> str:
    if pattern_type == "all0":
        return "0" * n
    elif pattern_type == "all1":
        return "1" * n
    elif pattern_type == "alt01":
        return ("01" * ((n + 1) // 2))[:n]
    else:
        raise ValueError(f"Unknown pattern_type: {pattern_type}")

def collect_single_pass_and_save(csv_path: str = None, show_preview: bool = True):
    # Define lengths and pattern types (as requested)
    lengths = [2 ** k for k in range(0, 9)]  # 1,2,4,...,256
    pattern_types = ["all0", "all1", "alt01"]

    # Build pattern set
    records = []
    combined_bits = []
    start_idx = 0
    for ptype in pattern_types:
        for n in lengths:
            bits = gen_pattern(ptype, n)
            end_idx = start_idx + n
            records.append({
                "pattern_id": f"{ptype}_N{n}",
                "pattern_type": ptype,
                "length": n,
                "start": start_idx,
                "end": end_idx,
                "input_bits": bits
            })
            combined_bits.append(bits)
            start_idx = end_idx

    combined_bits = "".join(combined_bits)

    # Send once
    combined_out = noisy_channel(combined_bits)

    # Sanity check
    if len(combined_out) != len(combined_bits):
        raise ValueError(f"Length mismatch: sent {len(combined_bits)} bits, received {len(combined_out)} bits")

    # Split back and compute stats
    out_rows = []
    for rec in records:
        s, e = rec["start"], rec["end"]
        inp = rec["input_bits"]
        out = combined_out[s:e]
        if len(out) != len(inp):
            raise ValueError(f"Slice length mismatch for {rec['pattern_id']}: {len(inp)} vs {len(out)}")

        ham = hamming_distance(inp, out)
        n = len(inp)
        # Flip breakdown
        flips_0_to_1 = sum(1 for a, b in zip(inp, out) if a == '0' and b == '1')
        flips_1_to_0 = sum(1 for a, b in zip(inp, out) if a == '1' and b == '0')

        out_rows.append({
            "pattern_id": rec["pattern_id"],
            "pattern_type": rec["pattern_type"],
            "length": n,
            "input_bits": inp,
            "output_bits": out,
            "hamming_distance": ham,
            "error_rate": ham / n if n > 0 else np.nan,
            "zeros_in": inp.count('0'),
            "ones_in": inp.count('1'),
            "flips_0_to_1": flips_0_to_1,
            "flips_1_to_0": flips_1_to_0
        })

    df = pd.DataFrame(out_rows).sort_values(by=["pattern_type", "length"]).reset_index(drop=True)

    # Save to CSV
    if csv_path is None:
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        csv_path = f"noisy_channel_singlepass_{ts}.csv"
    df.to_csv(csv_path, index=False)

    # Quick preview
    if show_preview:
        preview_cols = ["pattern_type", "length", "hamming_distance", "error_rate", "flips_0_to_1", "flips_1_to_0"]
        print("Saved results to:", csv_path)
        print(df[preview_cols].to_string(index=False))

    return df, csv_path

# Example run:
df, path = collect_single_pass_and_save()
print("Wrote:", path)